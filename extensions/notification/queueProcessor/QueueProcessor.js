'use strict'; // eslint-disable-line

const { EventEmitter } = require('events');

const Logger = require('werelogs').Logger;

const BackbeatConsumer = require('../../../lib/BackbeatConsumer');

class QueueProcessor extends EventEmitter {

    /**
     * Create a queue processor object to activate notification from a
     * kafka topic dedicated to dispatch messages to a destination/target.
     *
     * @constructor
     * @param {Object} kafkaConfig - kafka configuration object
     * @param {string} kafkaConfig.hosts - list of kafka brokers
     *   as "host:port[,host:port...]"
     * @param {Object} notifConfig - notification configuration object
     * @param {String} notifConfig.topic - notification topic name
     * @param {String} notifConfig.queueProcessor - config object
     *   specific to queue processor
     * @param {String} notifConfig.queueProcessor.groupId - kafka
     *   consumer group ID
     * @param {String} notifConfig.queueProcessor.retryTimeoutS -
     *   number of seconds before giving up retries of an entry
     * @param {String} destinationType - destination type
     */
    constructor(kafkaConfig, notifConfig, destinationType) {
        super();
        this.kafkaConfig = kafkaConfig;
        this.notifConfig = notifConfig;
        this._consumer = null;
        this._destinationType = destinationType;
        this._destination = null;

        this.logger = new Logger('Backbeat:Notification:QueueProcessor');
    }

    _getDestinationConfiguration() {
        // TODO: util function to fetch destination configuration from a file
        // check if this has to be moved to destination class.
        return undefined;
    }

    _setupDestination(destinationType, done) {
        // get the destination configuration
        // get destination object using the destination type
        // set the destination object to this._destination
        // this._destination.start();
        done();
    }

    /**
     * Start kafka consumer. Emits a 'ready' even when consumer is ready.
     *
     * Note: for tests, with auto.create.topics.enable option set on
     * kafka container, this will also pre-create the topic.
     *
     * @param {object} [options] options object
     * @param {boolean} [options.disableConsumer] - true to disable
     *   startup of consumer (for testing: one has to call
     *   processQueueEntry() explicitly)
     * @return {undefined}
     */
    start(options) {
        this._setupDestination(this.destinationType, err => {
            if (err) {
                this.logger.info('error setting up destination',
                    { error: err.message });
                return undefined;
            }
            if (options && options.disableConsumer) {
                this.emit('ready');
                return undefined;
            }
            const { groupId, concurrency, logConsumerMetricsIntervalS }
                = this.notifConfig.queueProcessor;
            this._consumer = new BackbeatConsumer({
                kafka: { hosts: this.kafkaConfig.hosts },
                topic: this.notifConfig.topic,
                groupId,
                concurrency,
                queueProcessor: this.processKafkaEntry.bind(this),
                logConsumerMetricsIntervalS,
            });
            this._consumer.on('error', () => { });
            this._consumer.on('ready', () => {
                this._consumer.subscribe();
                this.logger.info('queue processor is ready to consume ' +
                    'notification entries');
                this.emit('ready');
            });
            return undefined;
        });
    }

    /**
     * Stop kafka producer and consumer and commit current consumer
     * offset
     *
     * @param {function} done - callback
     * @return {undefined}
     */
    stop(done) {
        if (this._consumer) {
            this._consumer.close(done);
        } else {
            done();
        }
    }

    /**
     * Process kafka entry
     *
     * @param {object} kafkaEntry - entry generated by the queue populator
     * @param {function} done - callback function
     * @return {undefined}
     */
    processKafkaEntry(kafkaEntry, done) {
        const sourceEntry = JSON.parse(kafkaEntry.value);
        if (this._destination) {
            this._destination.send(sourceEntry);
        }

        return process.nextTick(done);
    }
}

module.exports = QueueProcessor;
